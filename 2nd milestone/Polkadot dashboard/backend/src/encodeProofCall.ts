import { ethers } from 'ethers';

async function main() {
  // Define the contract interface (ABI fragment) with the function signature
  const iface = new ethers.Interface([
    "function attest(uint256,uint256,uint256,string)"
  ]);

  // actual proof/parameters from your proofGenerator output
  const validatorId = 1;
  const nullifier = "18442506908470701556320229574649585818296137208334434509333321008118204014922";
  const externalNullifier = 1;
  const points = "3284477748700356856720594112437278134571839517219760696322650141341553963240,4341229978716990907687817885528317584290125292149313942624183112295642499742,4502944651765337783681670014397241658937872569207150883045862250287826054431,2174931470701968632690093656051026622637370686527779713764300011277674349322,12984140280547285890431062018445516196240836230644993157390546379284568386934,19030308698681882329499129534903779018572842265120889381764993409239733742647,13163310534910182574932905865276660338151212702161838867306795464947591487808,15444980720076680404255796396352900517280646036711319809692254139962176996313";

  // Encode the function call with parameters, producing the calldata hex string
  const data = iface.encodeFunctionData("attest", [
    validatorId,
    nullifier,
    externalNullifier,
    points
  ]);

  console.log("Encoded tx data:", data);
}

main().catch(console.error);
